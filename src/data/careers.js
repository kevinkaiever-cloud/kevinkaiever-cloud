const CAREER_GROUPS = {
  "传统": [
    "厨师", "厨师长", "面点师", "烘焙师", "理发师", "摄影师", "摆摊商贩", "农民", "果农", "渔民",
    "养殖工", "工厂工人", "纺织工", "制衣工", "食品加工工人", "制药工人", "矿工", "电工",
    "水管工", "电焊工", "木工", "瓦工", "泥瓦工", "抹灰工", "钢筋工", "油漆工",
    "建筑工人", "测量员", "高空作业工", "隧道工", "玻璃工", "石材工", "铝合金门窗工",
    "司机", "公交司机", "出租车司机", "货车司机", "冷链司机", "叉车司机",
    "装卸工", "搬运工", "锅炉工", "园林工", "保安", "保洁", "前台接待",
    "服务员", "客房服务员", "售货员", "收银员", "快递员", "仓库管理员", "库管员",
    "售票员", "导游", "景区工作人员", "票务员", "裁缝", "修鞋匠", "钟表维修",
    "家电维修", "手机维修", "汽修工", "洗车工", "美容师", "美甲师", "按摩师",
    "保姆", "月嫂", "护工"
  ],
  "现代": [
    "程序员", "后端开发工程师", "前端开发工程师", "全栈开发工程师", "移动端开发工程师",
    "测试工程师", "运维工程师", "DevOps工程师", "数据库管理员", "数据分析师", "数据工程师",
    "BI工程师", "数据可视化工程师", "数据治理工程师", "算法工程师", "机器学习工程师",
    "计算机视觉工程师", "自然语言处理工程师", "语音算法工程师", "地图算法工程师",
    "云计算架构师", "网络安全工程师", "信息安全经理", "IT支持工程师",
    "产品经理", "数据产品经理", "增长产品经理", "医疗产品经理", "教育产品经理",
    "UI设计师", "交互设计师", "视觉设计师", "用户研究员", "工业设计师",
    "游戏策划", "游戏开发", "游戏美术", "动画师", "剪辑师", "摄影后期",
    "产品运营", "用户增长", "内容运营", "社区运营", "电商运营", "新媒体运营",
    "市场营销", "品牌经理", "公关经理", "销售经理", "客户成功经理", "客服主管",
    "商业分析师", "投研分析师", "量化研究员", "投资经理", "风控分析师",
    "审计", "财务分析师", "人力资源", "招聘经理", "组织发展", "法务", "合规经理",
    "供应链经理", "采购经理", "物流经理", "项目经理", "PMO", "解决方案架构师",
    "售前工程师", "售后工程师", "技术写作", "企业咨询顾问", "商业运营",
    "战略规划", "ESG分析师", "碳管理经理", "环境工程师",
    "新能源电池工程师", "储能系统工程师", "光伏工程师", "电气工程师", "自动化工程师",
    "智能硬件工程师", "物联网工程师", "嵌入式工程师", "结构工程师", "机械工程师",
    "质量工程师", "工艺工程师", "生产计划", "精益生产工程师",
    "芯片设计工程师", "IC验证工程师", "半导体工艺工程师", "材料工程师",
    "机器人调试工程师", "汽车电子工程师", "自动驾驶工程师",
    "临床医生", "护理人员", "药剂师", "临床研究协调员", "药品注册专员",
    "医学编辑", "生物信息分析师", "食品安全工程师", "心理咨询师", "营养师",
    "健身教练", "康复治疗师", "中学教师", "大学讲师", "在线教育运营",
    "金融顾问", "理财经理", "保险精算师", "保险理赔专员", "银行客户经理",
    "证券经纪人", "基金经理", "房地产策划", "物业经理", "酒店经理",
    "旅行社产品经理", "跨境电商运营", "国际物流专员", "直播电商运营", "主播"
  ],
  "体制内": [
    "银行柜员", "公务员", "国企员工", "教师", "医生", "公立医院护士",
    "公立医院药师", "高校行政", "公共卫生专员", "社区社工", "街道办工作人员",
    "税务专员", "海关关员", "法院书记员", "检察官助理", "警察", "消防员", "军人",
    "事业单位管理", "邮政员工", "铁路调度员", "地铁站务员", "电力公司员工",
    "自来水公司员工", "公立学校教师", "国有企业工程师", "档案管理员",
    "统计局工作人员", "市场监管专员", "审计局工作人员", "交通管理执法",
    "公共资源交易管理", "政府信息化工程师"
  ],
  "AI": [
    "AI工程师", "AI算法工程师", "AI提示词工程师", "AI内容创作者", "AI产品经理",
    "虚拟人运营", "自动化运营专家", "智能体设计师", "AIGC设计师", "AIGC视频导演",
    "AI训练师", "AI质检师", "AI安全治理专家", "AI伦理官", "数字人产品经理",
    "机器人产品经理", "多模态算法工程师", "联邦学习工程师", "MLOps工程师",
    "AI知识库工程师", "RPA流程设计师", "低代码自动化工程师", "智能客服训练师",
    "AI教育导师", "AI商业顾问", "算力调度工程师", "数据标注经理"
  ],
  "自由职业": [
    "自由撰稿人", "插画师", "平面设计师", "配音演员", "翻译", "独立咨询顾问",
    "摄影工作室主理人", "婚礼策划师", "旅行定制师", "私人教练", "上门维修师",
    "手工艺人", "二手交易商", "网店店主", "直播带货", "宠物美容师",
    "宠物训练师", "家政服务经理", "微商", "二手车经纪人", "房地产中介",
    "保险代理人", "课程讲师", "音乐制作人", "独立游戏开发者", "模特经纪",
    "占星咨询师", "穿搭顾问", "纹身师"
  ]
};

const CATEGORY_BASE = {
  "传统": { risk: 6, growth: 35, ai: 45, stability: 65 },
  "现代": { risk: 5, growth: 62, ai: 38, stability: 58 },
  "体制内": { risk: 3, growth: 45, ai: 25, stability: 82 },
  "AI": { risk: 7, growth: 80, ai: 22, stability: 48 },
  "自由职业": { risk: 7, growth: 55, ai: 40, stability: 42 }
};

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function hashName(name) {
  let hash = 0;
  for (let i = 0; i < name.length; i += 1) {
    hash = (hash * 31 + name.charCodeAt(i)) % 100000;
  }
  return hash;
}

function createCareer(name, category) {
  const base = CATEGORY_BASE[category] || CATEGORY_BASE["现代"];
  const h = hashName(name);
  const jitter = (h % 13) - 6;
  return {
    career_name: name,
    category,
    risk_level: clamp(Math.round(base.risk + jitter * 0.2), 1, 10),
    growth_score: clamp(Math.round(base.growth + jitter * 1.6), 1, 100),
    ai_replace_risk: clamp(Math.round(base.ai + jitter * 1.8), 1, 100),
    stability_score: clamp(Math.round(base.stability - jitter * 1.4), 1, 100)
  };
}

function uniqueNames(groups) {
  const seen = new Set();
  const unique = {};
  Object.entries(groups).forEach(([category, list]) => {
    unique[category] = [];
    list.forEach((name) => {
      if (!seen.has(name)) {
        unique[category].push(name);
        seen.add(name);
      }
    });
  });
  return unique;
}

const UNIQUE_GROUPS = uniqueNames(CAREER_GROUPS);

const CAREER_DB = Object.entries(UNIQUE_GROUPS)
  .flatMap(([category, list]) => list.map((name) => createCareer(name, category)));

const CAREER_MAP = CAREER_DB.reduce((acc, item) => {
  acc[item.career_name] = item;
  return acc;
}, {});

export { CAREER_DB, CAREER_MAP, CAREER_GROUPS, CATEGORY_BASE };
